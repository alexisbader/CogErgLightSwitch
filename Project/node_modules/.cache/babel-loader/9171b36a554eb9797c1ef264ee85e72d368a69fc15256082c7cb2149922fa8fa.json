{"ast":null,"code":"var _jsxFileName = \"/Users/alexis/BME4A/BME543/Project/src/context/ExperimentContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { generateRandomRoomLayout, getRoomLetters } from '../utils/roomLayouts';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ExperimentContext = /*#__PURE__*/createContext();\nexport const useExperiment = () => {\n  _s();\n  const context = useContext(ExperimentContext);\n  if (!context) {\n    throw new Error('useExperiment must be used within ExperimentProvider');\n  }\n  return context;\n};\n_s(useExperiment, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const ExperimentProvider = ({\n  children\n}) => {\n  _s2();\n  // Participant info\n  const [participantId, setParticipantId] = useState('');\n  const [participantGroup, setParticipantGroup] = useState('');\n\n  // Current task state\n  const [currentCondition, setCurrentCondition] = useState(null);\n  const [designType, setDesignType] = useState('traditional'); // 'traditional' | 'buttons' | 'floorplan'\n  const [lightStatus, setLightStatus] = useState('allOff'); // 'allOff' | 'allOn' | 'mixed'\n  const [targetAreas, setTargetAreas] = useState([]); // ['A', 'B', etc.] - lights that should be ON\n  const [lightsToTurnOff, setLightsToTurnOff] = useState([]); // ['C', etc.] - lights that should be turned OFF (for mixed condition)\n\n  // Room layout and light states\n  const [roomLayout, setRoomLayout] = useState(null); // { numRooms, variation, rooms, roomIds }\n  const [lightStates, setLightStates] = useState({});\n  const [initialLightStates, setInitialLightStates] = useState({}); // Track initial state for task completion\n\n  // Floor plan orientation (0-180 degrees)\n  const [floorPlanOrientation, setFloorPlanOrientation] = useState(0);\n\n  // Error tracking - detailed log of switch presses\n  const [errorLog, setErrorLog] = useState([]); // Array of { areaId, timestamp, action, wasError }\n\n  // Task state\n  const [isTaskActive, setIsTaskActive] = useState(false);\n  const [taskStartTime, setTaskStartTime] = useState(null);\n  const [taskEndTime, setTaskEndTime] = useState(null);\n  const [errors, setErrors] = useState(0);\n  const [taskSuccess, setTaskSuccess] = useState(null); // null | true | false\n\n  // Timer\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const timerIntervalRef = useRef(null);\n  const taskCompletedRef = useRef(false);\n  const autoSavedRef = useRef(false);\n  const lastToggleRef = useRef({\n    areaId: null,\n    timestamp: 0\n  }); // Track last toggle to prevent duplicates\n\n  // All experiment data for CSV export\n  const [experimentData, setExperimentData] = useState([]);\n\n  // Survey data\n  const [surveyData, setSurveyData] = useState(null);\n\n  // Initialize light states based on lightStatus and room layout\n  const initializeLightStates = useCallback((status, roomIds) => {\n    const newStates = {};\n    roomIds.forEach(id => {\n      newStates[id] = false;\n    });\n    if (status === 'allOn') {\n      roomIds.forEach(key => {\n        newStates[key] = true;\n      });\n    } else if (status === 'mixed') {\n      // Randomly set 2 lights on\n      const shuffled = [...roomIds].sort(() => 0.5 - Math.random());\n      shuffled.slice(0, Math.min(2, roomIds.length)).forEach(key => {\n        newStates[key] = true;\n      });\n    }\n    return newStates;\n  }, []);\n\n  // Start task\n  const startTask = useCallback(condition => {\n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n\n    // Generate random room layout for this trial\n    const layout = generateRandomRoomLayout();\n    setRoomLayout(layout);\n\n    // Initialize light states based on condition\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff', layout.roomIds);\n    setInitialLightStates(initialStates); // Store initial state for task completion check\n    setLightStates(initialStates);\n\n    // Generate target areas based on task type\n    const taskType = condition.taskType || 'turnOn2';\n    let targets = [];\n    let toTurnOff = [];\n    if (taskType === 'turnOn2') {\n      // Task: Turn ON 2 lights (all lights start OFF)\n      // Select 2 random lights that are currently OFF to be targets\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const shuffled = [...offLights].sort(() => 0.5 - Math.random());\n      targets = shuffled.slice(0, Math.min(2, offLights.length));\n    } else if (taskType === 'turnOn1Off1') {\n      // Task: Turn ON 1 light, Turn OFF 1 light (mixed condition)\n      // Select 1 light that's currently OFF to turn ON\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const onLights = layout.roomIds.filter(id => initialStates[id]);\n      if (offLights.length > 0) {\n        const shuffledOff = [...offLights].sort(() => 0.5 - Math.random());\n        targets = [shuffledOff[0]]; // 1 target to turn ON\n      }\n      if (onLights.length > 0) {\n        const shuffledOn = [...onLights].sort(() => 0.5 - Math.random());\n        toTurnOff = [shuffledOn[0]]; // 1 light to turn OFF\n      }\n    }\n    setTargetAreas(targets);\n    setLightsToTurnOff(toTurnOff);\n    setErrors(0);\n    setTaskSuccess(null);\n    taskCompletedRef.current = false;\n    autoSavedRef.current = false;\n    setErrorLog([]); // Reset error log for new task\n    setTaskStartTime(Date.now());\n    setTaskEndTime(null);\n    setIsTaskActive(true);\n\n    // Start timer\n    setElapsedTime(0);\n    timerIntervalRef.current = setInterval(() => {\n      setElapsedTime(prev => prev + 1);\n    }, 1000);\n  }, [initializeLightStates]);\n\n  // Stop task\n  const stopTask = useCallback(() => {\n    setIsTaskActive(false);\n    setTaskEndTime(Date.now());\n    if (timerIntervalRef.current) {\n      clearInterval(timerIntervalRef.current);\n      timerIntervalRef.current = null;\n    }\n  }, []);\n\n  // Save task data\n  const saveTaskData = useCallback((survey = null) => {\n    if (!taskStartTime) return null;\n    const duration = taskEndTime ? (taskEndTime - taskStartTime) / 1000 : elapsedTime;\n\n    // Format error log for CSV\n    const errorLogString = errorLog.map(e => `${e.areaId}:${e.action}:${e.isError ? 'ERROR' : 'OK'}:${e.relativeTime}s`).join('; ');\n    const data = {\n      participant_id: participantId,\n      group: participantGroup,\n      design_type: designType,\n      lights_status: lightStatus,\n      task_type: (currentCondition === null || currentCondition === void 0 ? void 0 : currentCondition.taskType) || 'single',\n      num_rooms: (roomLayout === null || roomLayout === void 0 ? void 0 : roomLayout.numRooms) || 0,\n      room_variation: (roomLayout === null || roomLayout === void 0 ? void 0 : roomLayout.variation) || 0,\n      target_areas: targetAreas.join(','),\n      completion_time: duration,\n      errors: errors,\n      error_log: errorLogString,\n      success: taskSuccess === true,\n      nasa_tlx: (survey === null || survey === void 0 ? void 0 : survey.nasaTlx) || null,\n      confidence: (survey === null || survey === void 0 ? void 0 : survey.confidence) || null,\n      timestamp: new Date().toISOString()\n    };\n    setExperimentData(prev => [...prev, data]);\n    return data;\n  }, [participantId, participantGroup, designType, lightStatus, currentCondition, targetAreas, roomLayout, taskStartTime, taskEndTime, elapsedTime, errors, taskSuccess, errorLog]);\n\n  // Toggle light switch\n  const toggleSwitch = useCallback(areaId => {\n    if (!isTaskActive || taskCompletedRef.current) return;\n    const timestamp = Date.now();\n\n    // Prevent duplicate processing: if same area toggled within 100ms, skip\n    if (lastToggleRef.current.areaId === areaId && timestamp - lastToggleRef.current.timestamp < 100) {\n      return;\n    }\n\n    // Mark this toggle\n    lastToggleRef.current = {\n      areaId,\n      timestamp\n    };\n\n    // Read current state and calculate error BEFORE updating state\n    setLightStates(prev => {\n      const wasOn = prev[areaId];\n      const isNowOn = !wasOn;\n      const isTarget = targetAreas.includes(areaId);\n      const shouldTurnOff = lightsToTurnOff.includes(areaId);\n      const wasInitiallyOn = initialLightStates[areaId];\n      const relativeTime = taskStartTime ? (timestamp - taskStartTime) / 1000 : 0;\n\n      // Determine if this is an error based on task type\n      const taskType = (currentCondition === null || currentCondition === void 0 ? void 0 : currentCondition.taskType) || 'turnOn2';\n      let isError = false;\n      let action = '';\n      if (isNowOn && !wasOn) {\n        action = 'turned ON';\n        if (taskType === 'turnOn2') {\n          // For turnOn2: Only targets should be turned ON\n          if (!isTarget) {\n            isError = true; // Turning ON a non-target = ERROR\n          }\n        } else if (taskType === 'turnOn1Off1') {\n          // For turnOn1Off1: Only the target should be turned ON\n          if (!isTarget) {\n            isError = true; // Turning ON a non-target = ERROR\n          }\n        }\n      } else if (!isNowOn && wasOn) {\n        action = 'turned OFF';\n        if (taskType === 'turnOn2') {\n          // For turnOn2: Turning OFF is never an error (correcting)\n          isError = false;\n        } else if (taskType === 'turnOn1Off1') {\n          // For turnOn1Off1: Only the designated light should be turned OFF\n          if (shouldTurnOff) {\n            isError = false; // Turning OFF the designated light = OK\n          } else if (isTarget) {\n            isError = true; // Turning OFF a target = ERROR\n          } else if (wasInitiallyOn && !shouldTurnOff) {\n            isError = true; // Turning OFF a light that should remain ON = ERROR\n          } else {\n            isError = false; // Turning OFF a light that started OFF = OK (correcting)\n          }\n        }\n      }\n\n      // Create log entry - capture in closure for use outside\n      const logEntry = {\n        areaId,\n        timestamp,\n        relativeTime: relativeTime.toFixed(2),\n        action,\n        isTarget,\n        wasOn,\n        isNowOn,\n        isError\n      };\n\n      // Update error log and count AFTER state update (using closure to capture values)\n      // This setTimeout ensures error logging happens after state update completes\n      setTimeout(() => {\n        setErrorLog(prevLog => {\n          // Check if duplicate entry exists (same area, action, within 200ms)\n          const isDuplicate = prevLog.some(entry => entry.areaId === logEntry.areaId && entry.action === logEntry.action && Math.abs(entry.timestamp - logEntry.timestamp) < 200);\n          if (!isDuplicate) {\n            // Only increment error count if this is actually an error\n            if (logEntry.isError) {\n              setErrors(prevErrors => prevErrors + 1);\n            }\n            return [...prevLog, logEntry];\n          }\n          return prevLog;\n        });\n      }, 0);\n\n      // Create new state\n      const newState = {\n        ...prev,\n        [areaId]: isNowOn\n      };\n\n      // Check if task is complete based on task type (taskType already declared above)\n      let isComplete = false;\n      if (taskType === 'turnOn2') {\n        // All targets ON, all non-targets OFF\n        const roomIds = (roomLayout === null || roomLayout === void 0 ? void 0 : roomLayout.roomIds) || [];\n        const allTargetsOn = targetAreas.every(area => newState[area] === true);\n        const allNonTargetsOff = roomIds.filter(area => !targetAreas.includes(area)).every(area => newState[area] === false);\n        isComplete = allTargetsOn && allNonTargetsOff;\n      } else if (taskType === 'turnOn1Off1') {\n        // Target is ON, light to turn OFF is OFF, all others match initial state\n        const targetOn = targetAreas.every(area => newState[area] === true);\n        const toTurnOffOff = lightsToTurnOff.every(area => newState[area] === false);\n        const roomIds = (roomLayout === null || roomLayout === void 0 ? void 0 : roomLayout.roomIds) || [];\n        const othersMatchInitial = roomIds.filter(area => !targetAreas.includes(area) && !lightsToTurnOff.includes(area)).every(area => newState[area] === initialLightStates[area]);\n        isComplete = targetOn && toTurnOffOff && othersMatchInitial;\n      }\n      if (isComplete && !taskCompletedRef.current) {\n        taskCompletedRef.current = true;\n        setTaskSuccess(true);\n        stopTask();\n      }\n      return newState;\n    });\n  }, [isTaskActive, targetAreas, lightsToTurnOff, initialLightStates, currentCondition, roomLayout, stopTask, taskStartTime]);\n\n  // Mark task success/failure manually\n  const markTaskResult = useCallback(success => {\n    taskCompletedRef.current = true;\n    setTaskSuccess(success);\n    stopTask();\n  }, [stopTask]);\n\n  // Auto-save task data when task completes\n  useEffect(() => {\n    if (taskSuccess !== null && taskEndTime && taskStartTime && !autoSavedRef.current) {\n      // Auto-save without survey (survey can be added later via saveSurvey)\n      saveTaskData();\n      autoSavedRef.current = true;\n    }\n  }, [taskSuccess, taskEndTime, taskStartTime, saveTaskData]);\n\n  // Save survey data\n  const saveSurvey = useCallback(survey => {\n    setSurveyData(survey);\n    saveTaskData(survey);\n  }, [saveTaskData]);\n\n  // Helper function to escape CSV fields (wrap in quotes if contains comma)\n  const escapeCSVField = field => {\n    if (field === null || field === undefined) return '';\n    const str = String(field);\n    // If field contains comma, quote, or newline, wrap in quotes and escape internal quotes\n    if (str.includes(',') || str.includes('\"') || str.includes('\\n')) {\n      return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n  };\n\n  // Export to CSV\n  const exportToCSV = useCallback(() => {\n    if (experimentData.length === 0) return;\n    const headers = ['participant_id', 'group', 'design_type', 'lights_status', 'task_type', 'num_rooms', 'room_variation', 'target_areas', 'completion_time', 'errors', 'error_log', 'success', 'nasa_tlx', 'confidence', 'timestamp'];\n    const csvContent = [headers.join(','), ...experimentData.map(row => [escapeCSVField(row.participant_id), escapeCSVField(row.group), escapeCSVField(row.design_type), escapeCSVField(row.lights_status), escapeCSVField(row.task_type), escapeCSVField(row.num_rooms), escapeCSVField(row.room_variation), escapeCSVField(row.target_areas),\n    // This will be quoted since it contains commas\n    escapeCSVField(row.completion_time), escapeCSVField(row.errors), escapeCSVField(row.error_log || ''),\n    // Detailed error log\n    escapeCSVField(row.success), escapeCSVField(row.nasa_tlx || ''), escapeCSVField(row.confidence || ''), escapeCSVField(row.timestamp)].join(','))].join('\\n');\n    const blob = new Blob([csvContent], {\n      type: 'text/csv;charset=utf-8;'\n    });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `experiment_data_${participantId || 'export'}_${new Date().toISOString().split('T')[0]}.csv`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    window.URL.revokeObjectURL(url);\n  }, [experimentData, participantId]);\n\n  // Update condition data without starting task (for preview)\n  // Only updates if no task is currently active\n  const updateConditionData = useCallback(condition => {\n    // Don't update if a task is active - preserve the current trial\n    if (isTaskActive) {\n      return;\n    }\n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n\n    // Generate random room layout for preview\n    const layout = generateRandomRoomLayout();\n    setRoomLayout(layout);\n\n    // Initialize light states based on condition\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff', layout.roomIds);\n    setInitialLightStates(initialStates);\n    setLightStates(initialStates);\n\n    // Generate target areas for preview based on task type\n    const taskType = condition.taskType || 'turnOn2';\n    let targets = [];\n    let toTurnOff = [];\n    if (taskType === 'turnOn2') {\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const shuffled = [...offLights].sort(() => 0.5 - Math.random());\n      targets = shuffled.slice(0, Math.min(2, offLights.length));\n    } else if (taskType === 'turnOn1Off1') {\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const onLights = layout.roomIds.filter(id => initialStates[id]);\n      if (offLights.length > 0) {\n        const shuffledOff = [...offLights].sort(() => 0.5 - Math.random());\n        targets = [shuffledOff[0]];\n      }\n      if (onLights.length > 0) {\n        const shuffledOn = [...onLights].sort(() => 0.5 - Math.random());\n        toTurnOff = [shuffledOn[0]];\n      }\n    }\n    setTargetAreas(targets);\n    setLightsToTurnOff(toTurnOff);\n  }, [initializeLightStates, isTaskActive]);\n\n  // Reset for next condition\n  const resetForNextCondition = useCallback(() => {\n    setErrors(0);\n    setTaskSuccess(null);\n    taskCompletedRef.current = false;\n    autoSavedRef.current = false;\n    setElapsedTime(0);\n    setLightStates({});\n    setInitialLightStates({});\n    setTargetAreas([]);\n    setLightsToTurnOff([]);\n    setSurveyData(null);\n    setErrorLog([]);\n    lastToggleRef.current = {\n      areaId: null,\n      timestamp: 0\n    }; // Reset toggle tracking\n    // Note: Don't reset floorPlanOrientation here - let moderator control it\n  }, []);\n  const value = {\n    // Participant\n    participantId,\n    setParticipantId,\n    participantGroup,\n    setParticipantGroup,\n    // Task state\n    currentCondition,\n    designType,\n    lightStatus,\n    targetAreas,\n    lightsToTurnOff,\n    roomLayout,\n    lightStates,\n    floorPlanOrientation,\n    setFloorPlanOrientation,\n    isTaskActive,\n    taskStartTime,\n    taskEndTime,\n    errors,\n    taskSuccess,\n    elapsedTime,\n    errorLog,\n    // Data\n    experimentData,\n    surveyData,\n    // Actions\n    startTask,\n    stopTask,\n    toggleSwitch,\n    markTaskResult,\n    saveTaskData,\n    saveSurvey,\n    exportToCSV,\n    resetForNextCondition,\n    updateConditionData\n  };\n  return /*#__PURE__*/_jsxDEV(ExperimentContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 503,\n    columnNumber: 5\n  }, this);\n};\n_s2(ExperimentProvider, \"bHOgLJEJNwepqbD1dhNSBOUSlgI=\");\n_c = ExperimentProvider;\nvar _c;\n$RefreshReg$(_c, \"ExperimentProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useRef","useEffect","generateRandomRoomLayout","getRoomLetters","jsxDEV","_jsxDEV","ExperimentContext","useExperiment","_s","context","Error","ExperimentProvider","children","_s2","participantId","setParticipantId","participantGroup","setParticipantGroup","currentCondition","setCurrentCondition","designType","setDesignType","lightStatus","setLightStatus","targetAreas","setTargetAreas","lightsToTurnOff","setLightsToTurnOff","roomLayout","setRoomLayout","lightStates","setLightStates","initialLightStates","setInitialLightStates","floorPlanOrientation","setFloorPlanOrientation","errorLog","setErrorLog","isTaskActive","setIsTaskActive","taskStartTime","setTaskStartTime","taskEndTime","setTaskEndTime","errors","setErrors","taskSuccess","setTaskSuccess","elapsedTime","setElapsedTime","timerIntervalRef","taskCompletedRef","autoSavedRef","lastToggleRef","areaId","timestamp","experimentData","setExperimentData","surveyData","setSurveyData","initializeLightStates","status","roomIds","newStates","forEach","id","key","shuffled","sort","Math","random","slice","min","length","startTask","condition","layout","initialStates","taskType","targets","toTurnOff","offLights","filter","onLights","shuffledOff","shuffledOn","current","Date","now","setInterval","prev","stopTask","clearInterval","saveTaskData","survey","duration","errorLogString","map","e","action","isError","relativeTime","join","data","participant_id","group","design_type","lights_status","task_type","num_rooms","numRooms","room_variation","variation","target_areas","completion_time","error_log","success","nasa_tlx","nasaTlx","confidence","toISOString","toggleSwitch","wasOn","isNowOn","isTarget","includes","shouldTurnOff","wasInitiallyOn","logEntry","toFixed","setTimeout","prevLog","isDuplicate","some","entry","abs","prevErrors","newState","isComplete","allTargetsOn","every","area","allNonTargetsOff","targetOn","toTurnOffOff","othersMatchInitial","markTaskResult","saveSurvey","escapeCSVField","field","undefined","str","String","replace","exportToCSV","headers","csvContent","row","blob","Blob","type","url","window","URL","createObjectURL","a","document","createElement","href","download","split","body","appendChild","click","removeChild","revokeObjectURL","updateConditionData","resetForNextCondition","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/alexis/BME4A/BME543/Project/src/context/ExperimentContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { generateRandomRoomLayout, getRoomLetters } from '../utils/roomLayouts';\n\nconst ExperimentContext = createContext();\n\nexport const useExperiment = () => {\n  const context = useContext(ExperimentContext);\n  if (!context) {\n    throw new Error('useExperiment must be used within ExperimentProvider');\n  }\n  return context;\n};\n\nexport const ExperimentProvider = ({ children }) => {\n  // Participant info\n  const [participantId, setParticipantId] = useState('');\n  const [participantGroup, setParticipantGroup] = useState('');\n  \n  // Current task state\n  const [currentCondition, setCurrentCondition] = useState(null);\n  const [designType, setDesignType] = useState('traditional'); // 'traditional' | 'buttons' | 'floorplan'\n  const [lightStatus, setLightStatus] = useState('allOff'); // 'allOff' | 'allOn' | 'mixed'\n  const [targetAreas, setTargetAreas] = useState([]); // ['A', 'B', etc.] - lights that should be ON\n  const [lightsToTurnOff, setLightsToTurnOff] = useState([]); // ['C', etc.] - lights that should be turned OFF (for mixed condition)\n  \n  // Room layout and light states\n  const [roomLayout, setRoomLayout] = useState(null); // { numRooms, variation, rooms, roomIds }\n  const [lightStates, setLightStates] = useState({});\n  const [initialLightStates, setInitialLightStates] = useState({}); // Track initial state for task completion\n  \n  // Floor plan orientation (0-180 degrees)\n  const [floorPlanOrientation, setFloorPlanOrientation] = useState(0);\n  \n  // Error tracking - detailed log of switch presses\n  const [errorLog, setErrorLog] = useState([]); // Array of { areaId, timestamp, action, wasError }\n  \n  // Task state\n  const [isTaskActive, setIsTaskActive] = useState(false);\n  const [taskStartTime, setTaskStartTime] = useState(null);\n  const [taskEndTime, setTaskEndTime] = useState(null);\n  const [errors, setErrors] = useState(0);\n  const [taskSuccess, setTaskSuccess] = useState(null); // null | true | false\n  \n  // Timer\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const timerIntervalRef = useRef(null);\n  const taskCompletedRef = useRef(false);\n  const autoSavedRef = useRef(false);\n  const lastToggleRef = useRef({ areaId: null, timestamp: 0 }); // Track last toggle to prevent duplicates\n  \n  // All experiment data for CSV export\n  const [experimentData, setExperimentData] = useState([]);\n  \n  // Survey data\n  const [surveyData, setSurveyData] = useState(null);\n  \n  // Initialize light states based on lightStatus and room layout\n  const initializeLightStates = useCallback((status, roomIds) => {\n    const newStates = {};\n    roomIds.forEach(id => { newStates[id] = false; });\n    \n    if (status === 'allOn') {\n      roomIds.forEach(key => { newStates[key] = true; });\n    } else if (status === 'mixed') {\n      // Randomly set 2 lights on\n      const shuffled = [...roomIds].sort(() => 0.5 - Math.random());\n      shuffled.slice(0, Math.min(2, roomIds.length)).forEach(key => { newStates[key] = true; });\n    }\n    \n    return newStates;\n  }, []);\n  \n  // Start task\n  const startTask = useCallback((condition) => {\n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n    \n    // Generate random room layout for this trial\n    const layout = generateRandomRoomLayout();\n    setRoomLayout(layout);\n    \n    // Initialize light states based on condition\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff', layout.roomIds);\n    setInitialLightStates(initialStates); // Store initial state for task completion check\n    setLightStates(initialStates);\n    \n    // Generate target areas based on task type\n    const taskType = condition.taskType || 'turnOn2';\n    let targets = [];\n    let toTurnOff = [];\n    \n    if (taskType === 'turnOn2') {\n      // Task: Turn ON 2 lights (all lights start OFF)\n      // Select 2 random lights that are currently OFF to be targets\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const shuffled = [...offLights].sort(() => 0.5 - Math.random());\n      targets = shuffled.slice(0, Math.min(2, offLights.length));\n    } else if (taskType === 'turnOn1Off1') {\n      // Task: Turn ON 1 light, Turn OFF 1 light (mixed condition)\n      // Select 1 light that's currently OFF to turn ON\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const onLights = layout.roomIds.filter(id => initialStates[id]);\n      \n      if (offLights.length > 0) {\n        const shuffledOff = [...offLights].sort(() => 0.5 - Math.random());\n        targets = [shuffledOff[0]]; // 1 target to turn ON\n      }\n      \n      if (onLights.length > 0) {\n        const shuffledOn = [...onLights].sort(() => 0.5 - Math.random());\n        toTurnOff = [shuffledOn[0]]; // 1 light to turn OFF\n      }\n    }\n    \n    setTargetAreas(targets);\n    setLightsToTurnOff(toTurnOff);\n    \n    setErrors(0);\n    setTaskSuccess(null);\n    taskCompletedRef.current = false;\n    autoSavedRef.current = false;\n    setErrorLog([]); // Reset error log for new task\n    setTaskStartTime(Date.now());\n    setTaskEndTime(null);\n    \n    setIsTaskActive(true);\n    \n    // Start timer\n    setElapsedTime(0);\n    timerIntervalRef.current = setInterval(() => {\n      setElapsedTime(prev => prev + 1);\n    }, 1000);\n  }, [initializeLightStates]);\n  \n  // Stop task\n  const stopTask = useCallback(() => {\n    setIsTaskActive(false);\n    setTaskEndTime(Date.now());\n    if (timerIntervalRef.current) {\n      clearInterval(timerIntervalRef.current);\n      timerIntervalRef.current = null;\n    }\n  }, []);\n  \n  // Save task data\n  const saveTaskData = useCallback((survey = null) => {\n    if (!taskStartTime) return null;\n    \n    const duration = taskEndTime ? (taskEndTime - taskStartTime) / 1000 : elapsedTime;\n    \n    // Format error log for CSV\n    const errorLogString = errorLog.map(e => \n      `${e.areaId}:${e.action}:${e.isError ? 'ERROR' : 'OK'}:${e.relativeTime}s`\n    ).join('; ');\n    \n    const data = {\n      participant_id: participantId,\n      group: participantGroup,\n      design_type: designType,\n      lights_status: lightStatus,\n      task_type: currentCondition?.taskType || 'single',\n      num_rooms: roomLayout?.numRooms || 0,\n      room_variation: roomLayout?.variation || 0,\n      target_areas: targetAreas.join(','),\n      completion_time: duration,\n      errors: errors,\n      error_log: errorLogString,\n      success: taskSuccess === true,\n      nasa_tlx: survey?.nasaTlx || null,\n      confidence: survey?.confidence || null,\n      timestamp: new Date().toISOString()\n    };\n    \n    setExperimentData(prev => [...prev, data]);\n    return data;\n  }, [participantId, participantGroup, designType, lightStatus, currentCondition, targetAreas, roomLayout,\n      taskStartTime, taskEndTime, elapsedTime, errors, taskSuccess, errorLog]);\n  \n  // Toggle light switch\n  const toggleSwitch = useCallback((areaId) => {\n    if (!isTaskActive || taskCompletedRef.current) return;\n    \n    const timestamp = Date.now();\n    \n    // Prevent duplicate processing: if same area toggled within 100ms, skip\n    if (lastToggleRef.current.areaId === areaId && \n        timestamp - lastToggleRef.current.timestamp < 100) {\n      return;\n    }\n    \n    // Mark this toggle\n    lastToggleRef.current = { areaId, timestamp };\n    \n    // Read current state and calculate error BEFORE updating state\n    setLightStates(prev => {\n      const wasOn = prev[areaId];\n      const isNowOn = !wasOn;\n      const isTarget = targetAreas.includes(areaId);\n      const shouldTurnOff = lightsToTurnOff.includes(areaId);\n      const wasInitiallyOn = initialLightStates[areaId];\n      const relativeTime = taskStartTime ? (timestamp - taskStartTime) / 1000 : 0;\n      \n      // Determine if this is an error based on task type\n      const taskType = currentCondition?.taskType || 'turnOn2';\n      let isError = false;\n      let action = '';\n      \n      if (isNowOn && !wasOn) {\n        action = 'turned ON';\n        if (taskType === 'turnOn2') {\n          // For turnOn2: Only targets should be turned ON\n          if (!isTarget) {\n            isError = true; // Turning ON a non-target = ERROR\n          }\n        } else if (taskType === 'turnOn1Off1') {\n          // For turnOn1Off1: Only the target should be turned ON\n          if (!isTarget) {\n            isError = true; // Turning ON a non-target = ERROR\n          }\n        }\n      } else if (!isNowOn && wasOn) {\n        action = 'turned OFF';\n        if (taskType === 'turnOn2') {\n          // For turnOn2: Turning OFF is never an error (correcting)\n          isError = false;\n        } else if (taskType === 'turnOn1Off1') {\n          // For turnOn1Off1: Only the designated light should be turned OFF\n          if (shouldTurnOff) {\n            isError = false; // Turning OFF the designated light = OK\n          } else if (isTarget) {\n            isError = true; // Turning OFF a target = ERROR\n          } else if (wasInitiallyOn && !shouldTurnOff) {\n            isError = true; // Turning OFF a light that should remain ON = ERROR\n          } else {\n            isError = false; // Turning OFF a light that started OFF = OK (correcting)\n          }\n        }\n      }\n      \n      // Create log entry - capture in closure for use outside\n      const logEntry = {\n        areaId,\n        timestamp,\n        relativeTime: relativeTime.toFixed(2),\n        action,\n        isTarget,\n        wasOn,\n        isNowOn,\n        isError\n      };\n      \n      // Update error log and count AFTER state update (using closure to capture values)\n      // This setTimeout ensures error logging happens after state update completes\n      setTimeout(() => {\n        setErrorLog(prevLog => {\n          // Check if duplicate entry exists (same area, action, within 200ms)\n          const isDuplicate = prevLog.some(entry => \n            entry.areaId === logEntry.areaId && \n            entry.action === logEntry.action &&\n            Math.abs(entry.timestamp - logEntry.timestamp) < 200\n          );\n          \n          if (!isDuplicate) {\n            // Only increment error count if this is actually an error\n            if (logEntry.isError) {\n              setErrors(prevErrors => prevErrors + 1);\n            }\n            return [...prevLog, logEntry];\n          }\n          return prevLog;\n        });\n      }, 0);\n      \n      // Create new state\n      const newState = { ...prev, [areaId]: isNowOn };\n      \n      // Check if task is complete based on task type (taskType already declared above)\n      let isComplete = false;\n      \n      if (taskType === 'turnOn2') {\n        // All targets ON, all non-targets OFF\n        const roomIds = roomLayout?.roomIds || [];\n        const allTargetsOn = targetAreas.every(area => newState[area] === true);\n        const allNonTargetsOff = roomIds\n          .filter(area => !targetAreas.includes(area))\n          .every(area => newState[area] === false);\n        isComplete = allTargetsOn && allNonTargetsOff;\n      } else if (taskType === 'turnOn1Off1') {\n        // Target is ON, light to turn OFF is OFF, all others match initial state\n        const targetOn = targetAreas.every(area => newState[area] === true);\n        const toTurnOffOff = lightsToTurnOff.every(area => newState[area] === false);\n        const roomIds = roomLayout?.roomIds || [];\n        const othersMatchInitial = roomIds\n          .filter(area => !targetAreas.includes(area) && !lightsToTurnOff.includes(area))\n          .every(area => newState[area] === initialLightStates[area]);\n        isComplete = targetOn && toTurnOffOff && othersMatchInitial;\n      }\n      \n      if (isComplete && !taskCompletedRef.current) {\n        taskCompletedRef.current = true;\n        setTaskSuccess(true);\n        stopTask();\n      }\n      \n      return newState;\n    });\n    }, [isTaskActive, targetAreas, lightsToTurnOff, initialLightStates, currentCondition, roomLayout, stopTask, taskStartTime]);\n  \n  // Mark task success/failure manually\n  const markTaskResult = useCallback((success) => {\n    taskCompletedRef.current = true;\n    setTaskSuccess(success);\n    stopTask();\n  }, [stopTask]);\n  \n  // Auto-save task data when task completes\n  useEffect(() => {\n    if (taskSuccess !== null && taskEndTime && taskStartTime && !autoSavedRef.current) {\n      // Auto-save without survey (survey can be added later via saveSurvey)\n      saveTaskData();\n      autoSavedRef.current = true;\n    }\n  }, [taskSuccess, taskEndTime, taskStartTime, saveTaskData]);\n  \n  // Save survey data\n  const saveSurvey = useCallback((survey) => {\n    setSurveyData(survey);\n    saveTaskData(survey);\n  }, [saveTaskData]);\n  \n  // Helper function to escape CSV fields (wrap in quotes if contains comma)\n  const escapeCSVField = (field) => {\n    if (field === null || field === undefined) return '';\n    const str = String(field);\n    // If field contains comma, quote, or newline, wrap in quotes and escape internal quotes\n    if (str.includes(',') || str.includes('\"') || str.includes('\\n')) {\n      return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n  };\n  \n  // Export to CSV\n  const exportToCSV = useCallback(() => {\n    if (experimentData.length === 0) return;\n    \n    const headers = [\n      'participant_id',\n      'group',\n      'design_type',\n      'lights_status',\n      'task_type',\n      'num_rooms',\n      'room_variation',\n      'target_areas',\n      'completion_time',\n      'errors',\n      'error_log',\n      'success',\n      'nasa_tlx',\n      'confidence',\n      'timestamp'\n    ];\n    \n    const csvContent = [\n      headers.join(','),\n      ...experimentData.map(row => [\n        escapeCSVField(row.participant_id),\n        escapeCSVField(row.group),\n        escapeCSVField(row.design_type),\n        escapeCSVField(row.lights_status),\n        escapeCSVField(row.task_type),\n        escapeCSVField(row.num_rooms),\n        escapeCSVField(row.room_variation),\n        escapeCSVField(row.target_areas), // This will be quoted since it contains commas\n        escapeCSVField(row.completion_time),\n        escapeCSVField(row.errors),\n        escapeCSVField(row.error_log || ''), // Detailed error log\n        escapeCSVField(row.success),\n        escapeCSVField(row.nasa_tlx || ''),\n        escapeCSVField(row.confidence || ''),\n        escapeCSVField(row.timestamp)\n      ].join(','))\n    ].join('\\n');\n    \n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `experiment_data_${participantId || 'export'}_${new Date().toISOString().split('T')[0]}.csv`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    window.URL.revokeObjectURL(url);\n  }, [experimentData, participantId]);\n  \n  // Update condition data without starting task (for preview)\n  // Only updates if no task is currently active\n  const updateConditionData = useCallback((condition) => {\n    // Don't update if a task is active - preserve the current trial\n    if (isTaskActive) {\n      return;\n    }\n    \n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n    \n    // Generate random room layout for preview\n    const layout = generateRandomRoomLayout();\n    setRoomLayout(layout);\n    \n    // Initialize light states based on condition\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff', layout.roomIds);\n    setInitialLightStates(initialStates);\n    setLightStates(initialStates);\n    \n    // Generate target areas for preview based on task type\n    const taskType = condition.taskType || 'turnOn2';\n    let targets = [];\n    let toTurnOff = [];\n    \n    if (taskType === 'turnOn2') {\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const shuffled = [...offLights].sort(() => 0.5 - Math.random());\n      targets = shuffled.slice(0, Math.min(2, offLights.length));\n    } else if (taskType === 'turnOn1Off1') {\n      const offLights = layout.roomIds.filter(id => !initialStates[id]);\n      const onLights = layout.roomIds.filter(id => initialStates[id]);\n      if (offLights.length > 0) {\n        const shuffledOff = [...offLights].sort(() => 0.5 - Math.random());\n        targets = [shuffledOff[0]];\n      }\n      if (onLights.length > 0) {\n        const shuffledOn = [...onLights].sort(() => 0.5 - Math.random());\n        toTurnOff = [shuffledOn[0]];\n      }\n    }\n    \n    setTargetAreas(targets);\n    setLightsToTurnOff(toTurnOff);\n  }, [initializeLightStates, isTaskActive]);\n  \n  // Reset for next condition\n  const resetForNextCondition = useCallback(() => {\n    setErrors(0);\n    setTaskSuccess(null);\n    taskCompletedRef.current = false;\n    autoSavedRef.current = false;\n    setElapsedTime(0);\n    setLightStates({});\n    setInitialLightStates({});\n    setTargetAreas([]);\n    setLightsToTurnOff([]);\n    setSurveyData(null);\n    setErrorLog([]);\n    lastToggleRef.current = { areaId: null, timestamp: 0 }; // Reset toggle tracking\n    // Note: Don't reset floorPlanOrientation here - let moderator control it\n  }, []);\n  \n  const value = {\n    // Participant\n    participantId,\n    setParticipantId,\n    participantGroup,\n    setParticipantGroup,\n    \n    // Task state\n    currentCondition,\n    designType,\n    lightStatus,\n    targetAreas,\n    lightsToTurnOff,\n    roomLayout,\n    lightStates,\n    floorPlanOrientation,\n    setFloorPlanOrientation,\n    isTaskActive,\n    taskStartTime,\n    taskEndTime,\n    errors,\n    taskSuccess,\n    elapsedTime,\n    errorLog,\n    \n    // Data\n    experimentData,\n    surveyData,\n    \n    // Actions\n    startTask,\n    stopTask,\n    toggleSwitch,\n    markTaskResult,\n    saveTaskData,\n    saveSurvey,\n    exportToCSV,\n    resetForNextCondition,\n    updateConditionData\n  };\n  \n  return (\n    <ExperimentContext.Provider value={value}>\n      {children}\n    </ExperimentContext.Provider>\n  );\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}