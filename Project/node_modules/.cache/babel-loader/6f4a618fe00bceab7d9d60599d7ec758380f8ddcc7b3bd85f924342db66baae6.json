{"ast":null,"code":"import _objectSpread from\"/Users/alexis/BME4A/BME543/Project/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useCallback,useRef,useEffect}from'react';import{generateRandomRoomLayout,getRoomLetters}from'../utils/roomLayouts';import{jsx as _jsx}from\"react/jsx-runtime\";const ExperimentContext=/*#__PURE__*/createContext();export const useExperiment=()=>{const context=useContext(ExperimentContext);if(!context){throw new Error('useExperiment must be used within ExperimentProvider');}return context;};export const ExperimentProvider=_ref=>{let{children}=_ref;// Participant info\nconst[participantId,setParticipantId]=useState('');const[participantGroup,setParticipantGroup]=useState('');// Current task state\nconst[currentCondition,setCurrentCondition]=useState(null);const[designType,setDesignType]=useState('traditional');// 'traditional' | 'buttons' | 'floorplan'\nconst[lightStatus,setLightStatus]=useState('allOff');// 'allOff' | 'allOn' | 'mixed'\nconst[targetAreas,setTargetAreas]=useState([]);// ['A', 'B', etc.] - lights to turn ON\nconst[lightsToTurnOff,setLightsToTurnOff]=useState([]);// ['C', 'D', etc.] - lights to turn OFF\n// Room layout and light states\nconst[roomLayout,setRoomLayout]=useState(null);// { numRooms, variation, rooms, roomIds }\nconst[lightStates,setLightStates]=useState({});// Floor plan orientation (0-180 degrees)\nconst[floorPlanOrientation,setFloorPlanOrientation]=useState(0);// Error tracking - detailed log of switch presses\nconst[errorLog,setErrorLog]=useState([]);// Array of { areaId, timestamp, action, wasError }\n// Task state\nconst[isTaskActive,setIsTaskActive]=useState(false);const[taskStartTime,setTaskStartTime]=useState(null);const[taskEndTime,setTaskEndTime]=useState(null);const[errors,setErrors]=useState(0);const[taskSuccess,setTaskSuccess]=useState(null);// null | true | false\n// Timer\nconst[elapsedTime,setElapsedTime]=useState(0);const timerIntervalRef=useRef(null);const taskCompletedRef=useRef(false);const autoSavedRef=useRef(false);const lastToggleRef=useRef({areaId:null,timestamp:0});// Track last toggle to prevent duplicates\n// All experiment data for CSV export\nconst[experimentData,setExperimentData]=useState([]);// Survey data\nconst[surveyData,setSurveyData]=useState(null);// Initialize light states based on lightStatus and room layout\nconst initializeLightStates=useCallback((status,roomIds)=>{const newStates={};roomIds.forEach(id=>{newStates[id]=false;});if(status==='allOn'){roomIds.forEach(key=>{newStates[key]=true;});}else if(status==='mixed'){// Randomly set 2 lights on\nconst shuffled=[...roomIds].sort(()=>0.5-Math.random());shuffled.slice(0,Math.min(2,roomIds.length)).forEach(key=>{newStates[key]=true;});}return newStates;},[]);// Start task\nconst startTask=useCallback(condition=>{setCurrentCondition(condition);setDesignType(condition.designType||'traditional');setLightStatus(condition.lightStatus||'allOff');// Generate random room layout for this trial\nconst layout=generateRandomRoomLayout();setRoomLayout(layout);// Initialize light states first (based on lightStatus)\nconst initialStates=initializeLightStates(condition.lightStatus||'allOff',layout.roomIds);setLightStates(initialStates);// Generate target areas based on task type\nconst taskType=condition.taskType||'turnOn2';const shuffled=[...layout.roomIds].sort(()=>0.5-Math.random());if(taskType==='turnOn2'){// Turn ON 2 lights\nconst targets=shuffled.slice(0,Math.min(2,layout.roomIds.length));setTargetAreas(targets);setLightsToTurnOff([]);}else if(taskType==='turnOn1Off1'){// Turn ON 1 light, turn OFF 1 light\n// For turnOn1Off1, we need at least one light that is currently ON to turn OFF\nconst lightsCurrentlyOn=layout.roomIds.filter(id=>initialStates[id]===true);const lightsCurrentlyOff=layout.roomIds.filter(id=>initialStates[id]===false);if(lightsCurrentlyOn.length>0&&lightsCurrentlyOff.length>0){// Pick one light to turn ON (from currently OFF)\nconst turnOnTarget=lightsCurrentlyOff[Math.floor(Math.random()*lightsCurrentlyOff.length)];// Pick one light to turn OFF (from currently ON)\nconst turnOffTarget=lightsCurrentlyOn[Math.floor(Math.random()*lightsCurrentlyOn.length)];setTargetAreas([turnOnTarget]);setLightsToTurnOff([turnOffTarget]);}else{// Fallback: if all lights are same state, just pick random ones\nconst turnOnTarget=shuffled[0];const turnOffTarget=shuffled[1]||shuffled[0];setTargetAreas([turnOnTarget]);setLightsToTurnOff([turnOffTarget]);}}else{// Default: turn ON 2 lights\nconst targets=shuffled.slice(0,Math.min(2,layout.roomIds.length));setTargetAreas(targets);setLightsToTurnOff([]);}setErrors(0);setTaskSuccess(null);taskCompletedRef.current=false;autoSavedRef.current=false;setErrorLog([]);// Reset error log for new task\nsetTaskStartTime(Date.now());setTaskEndTime(null);setIsTaskActive(true);// Start timer\nsetElapsedTime(0);timerIntervalRef.current=setInterval(()=>{setElapsedTime(prev=>prev+1);},1000);},[initializeLightStates]);// Stop task\nconst stopTask=useCallback(()=>{setIsTaskActive(false);setTaskEndTime(Date.now());if(timerIntervalRef.current){clearInterval(timerIntervalRef.current);timerIntervalRef.current=null;}},[]);// Save task data\nconst saveTaskData=useCallback(function(){let survey=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;if(!taskStartTime)return null;const duration=taskEndTime?(taskEndTime-taskStartTime)/1000:elapsedTime;// Format error log for CSV\nconst errorLogString=errorLog.map(e=>\"\".concat(e.areaId,\":\").concat(e.action,\":\").concat(e.isError?'ERROR':'OK',\":\").concat(e.relativeTime,\"s\")).join('; ');const data={participant_id:participantId,group:participantGroup,design_type:designType,lights_status:lightStatus,task_type:(currentCondition===null||currentCondition===void 0?void 0:currentCondition.taskType)||'turnOn2',num_rooms:(roomLayout===null||roomLayout===void 0?void 0:roomLayout.numRooms)||0,room_variation:(roomLayout===null||roomLayout===void 0?void 0:roomLayout.variation)||0,target_areas:targetAreas.join(','),lights_to_turn_off:lightsToTurnOff.join(','),completion_time:duration,errors:errors,error_log:errorLogString,success:taskSuccess===true,nasa_tlx:(survey===null||survey===void 0?void 0:survey.nasaTlx)||null,confidence:(survey===null||survey===void 0?void 0:survey.confidence)||null,timestamp:new Date().toISOString()};setExperimentData(prev=>[...prev,data]);return data;},[participantId,participantGroup,designType,lightStatus,currentCondition,targetAreas,lightsToTurnOff,roomLayout,taskStartTime,taskEndTime,elapsedTime,errors,taskSuccess,errorLog]);// Toggle light switch\nconst toggleSwitch=useCallback(areaId=>{// Only allow toggles when task is active\n// Task completion is manual - moderator must mark it, so we don't check taskCompletedRef here\nif(!isTaskActive)return;const timestamp=Date.now();// Prevent duplicate processing: if same area toggled within 100ms, skip\nif(lastToggleRef.current.areaId===areaId&&timestamp-lastToggleRef.current.timestamp<100){return;}// Mark this toggle\nlastToggleRef.current={areaId,timestamp};// Read current state and calculate error BEFORE updating state\nsetLightStates(prev=>{const wasOn=prev[areaId];const isNowOn=!wasOn;const isTarget=targetAreas.includes(areaId);const relativeTime=taskStartTime?(timestamp-taskStartTime)/1000:0;// Determine if this is an error:\n// - Turning ON a non-target area = ERROR\n// - Turning OFF = NOT an error (correcting/undoing)\n// - Turning ON a target area = NOT an error (correct action)\nlet isError=false;let action='';if(isNowOn&&!wasOn){action='turned ON';if(!isTarget){isError=true;// Turning ON a non-target = ERROR\n}}else if(!isNowOn&&wasOn){action='turned OFF';isError=false;// Turning OFF is never an error\n}// Create log entry - capture in closure for use outside\nconst logEntry={areaId,timestamp,relativeTime:relativeTime.toFixed(2),action,isTarget,wasOn,isNowOn,isError};// Update error log and count AFTER state update (using closure to capture values)\n// This setTimeout ensures error logging happens after state update completes\nsetTimeout(()=>{setErrorLog(prevLog=>{// Check if duplicate entry exists (same area, action, within 200ms)\nconst isDuplicate=prevLog.some(entry=>entry.areaId===logEntry.areaId&&entry.action===logEntry.action&&Math.abs(entry.timestamp-logEntry.timestamp)<200);if(!isDuplicate){// Only increment error count if this is actually an error\nif(logEntry.isError){setErrors(prevErrors=>prevErrors+1);}return[...prevLog,logEntry];}return prevLog;});},0);// Create new state\nconst newState=_objectSpread(_objectSpread({},prev),{},{[areaId]:isNowOn});// Task completion is now manual - moderator must mark success/failure\n// No automatic completion check here\nreturn newState;});},[isTaskActive,targetAreas,lightsToTurnOff,currentCondition,roomLayout,stopTask,taskStartTime]);// Mark task success/failure manually\nconst markTaskResult=useCallback(success=>{taskCompletedRef.current=true;setTaskSuccess(success);stopTask();},[stopTask]);// Auto-save task data when task completes\nuseEffect(()=>{if(taskSuccess!==null&&taskEndTime&&taskStartTime&&!autoSavedRef.current){// Auto-save without survey (survey can be added later via saveSurvey)\nsaveTaskData();autoSavedRef.current=true;}},[taskSuccess,taskEndTime,taskStartTime,saveTaskData]);// Save survey data\nconst saveSurvey=useCallback(survey=>{setSurveyData(survey);saveTaskData(survey);},[saveTaskData]);// Helper function to escape CSV fields (wrap in quotes if contains comma)\nconst escapeCSVField=field=>{if(field===null||field===undefined)return'';const str=String(field);// If field contains comma, quote, or newline, wrap in quotes and escape internal quotes\nif(str.includes(',')||str.includes('\"')||str.includes('\\n')){return\"\\\"\".concat(str.replace(/\"/g,'\"\"'),\"\\\"\");}return str;};// Export to CSV\nconst exportToCSV=useCallback(()=>{if(experimentData.length===0)return;const headers=['participant_id','group','design_type','lights_status','task_type','num_rooms','room_variation','target_areas','lights_to_turn_off','completion_time','errors','error_log','success','nasa_tlx','confidence','timestamp'];const csvContent=[headers.join(','),...experimentData.map(row=>[escapeCSVField(row.participant_id),escapeCSVField(row.group),escapeCSVField(row.design_type),escapeCSVField(row.lights_status),escapeCSVField(row.task_type),escapeCSVField(row.num_rooms),escapeCSVField(row.room_variation),escapeCSVField(row.target_areas),// This will be quoted since it contains commas\nescapeCSVField(row.lights_to_turn_off||''),// This will be quoted since it contains commas\nescapeCSVField(row.completion_time),escapeCSVField(row.errors),escapeCSVField(row.error_log||''),// Detailed error log\nescapeCSVField(row.success),escapeCSVField(row.nasa_tlx||''),escapeCSVField(row.confidence||''),escapeCSVField(row.timestamp)].join(','))].join('\\n');const blob=new Blob([csvContent],{type:'text/csv;charset=utf-8;'});const url=window.URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download=\"experiment_data_\".concat(participantId||'export',\"_\").concat(new Date().toISOString().split('T')[0],\".csv\");document.body.appendChild(a);a.click();document.body.removeChild(a);window.URL.revokeObjectURL(url);},[experimentData,participantId]);// Update condition data without starting task (for preview)\n// Only updates if no task is currently active\nconst updateConditionData=useCallback(condition=>{// Don't update if a task is active - preserve the current trial\nif(isTaskActive){return;}setCurrentCondition(condition);setDesignType(condition.designType||'traditional');setLightStatus(condition.lightStatus||'allOff');// Generate random room layout for preview\nconst layout=generateRandomRoomLayout();setRoomLayout(layout);// Initialize light states first (based on lightStatus)\nconst initialStates=initializeLightStates(condition.lightStatus||'allOff',layout.roomIds);setLightStates(initialStates);// Generate target areas for preview based on task type\nconst taskType=condition.taskType||'turnOn2';const shuffled=[...layout.roomIds].sort(()=>0.5-Math.random());if(taskType==='turnOn2'){const targets=shuffled.slice(0,Math.min(2,layout.roomIds.length));setTargetAreas(targets);setLightsToTurnOff([]);}else if(taskType==='turnOn1Off1'){const lightsCurrentlyOn=layout.roomIds.filter(id=>initialStates[id]===true);const lightsCurrentlyOff=layout.roomIds.filter(id=>initialStates[id]===false);if(lightsCurrentlyOn.length>0&&lightsCurrentlyOff.length>0){const turnOnTarget=lightsCurrentlyOff[Math.floor(Math.random()*lightsCurrentlyOff.length)];const turnOffTarget=lightsCurrentlyOn[Math.floor(Math.random()*lightsCurrentlyOn.length)];setTargetAreas([turnOnTarget]);setLightsToTurnOff([turnOffTarget]);}else{const turnOnTarget=shuffled[0];const turnOffTarget=shuffled[1]||shuffled[0];setTargetAreas([turnOnTarget]);setLightsToTurnOff([turnOffTarget]);}}else{const targets=shuffled.slice(0,Math.min(2,layout.roomIds.length));setTargetAreas(targets);setLightsToTurnOff([]);}},[initializeLightStates,isTaskActive]);// Reset for next condition\nconst resetForNextCondition=useCallback(()=>{setErrors(0);setTaskSuccess(null);taskCompletedRef.current=false;autoSavedRef.current=false;setElapsedTime(0);setLightStates({});setSurveyData(null);setErrorLog([]);setLightsToTurnOff([]);lastToggleRef.current={areaId:null,timestamp:0};// Reset toggle tracking\n// Note: Don't reset floorPlanOrientation here - let moderator control it\n},[]);const value={// Participant\nparticipantId,setParticipantId,participantGroup,setParticipantGroup,// Task state\ncurrentCondition,designType,lightStatus,targetAreas,lightsToTurnOff,roomLayout,lightStates,floorPlanOrientation,setFloorPlanOrientation,isTaskActive,taskStartTime,taskEndTime,errors,taskSuccess,elapsedTime,errorLog,// Data\nexperimentData,surveyData,// Actions\nstartTask,stopTask,toggleSwitch,markTaskResult,saveTaskData,saveSurvey,exportToCSV,resetForNextCondition,updateConditionData};return/*#__PURE__*/_jsx(ExperimentContext.Provider,{value:value,children:children});};","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useRef","useEffect","generateRandomRoomLayout","getRoomLetters","jsx","_jsx","ExperimentContext","useExperiment","context","Error","ExperimentProvider","_ref","children","participantId","setParticipantId","participantGroup","setParticipantGroup","currentCondition","setCurrentCondition","designType","setDesignType","lightStatus","setLightStatus","targetAreas","setTargetAreas","lightsToTurnOff","setLightsToTurnOff","roomLayout","setRoomLayout","lightStates","setLightStates","floorPlanOrientation","setFloorPlanOrientation","errorLog","setErrorLog","isTaskActive","setIsTaskActive","taskStartTime","setTaskStartTime","taskEndTime","setTaskEndTime","errors","setErrors","taskSuccess","setTaskSuccess","elapsedTime","setElapsedTime","timerIntervalRef","taskCompletedRef","autoSavedRef","lastToggleRef","areaId","timestamp","experimentData","setExperimentData","surveyData","setSurveyData","initializeLightStates","status","roomIds","newStates","forEach","id","key","shuffled","sort","Math","random","slice","min","length","startTask","condition","layout","initialStates","taskType","targets","lightsCurrentlyOn","filter","lightsCurrentlyOff","turnOnTarget","floor","turnOffTarget","current","Date","now","setInterval","prev","stopTask","clearInterval","saveTaskData","survey","arguments","undefined","duration","errorLogString","map","e","concat","action","isError","relativeTime","join","data","participant_id","group","design_type","lights_status","task_type","num_rooms","numRooms","room_variation","variation","target_areas","lights_to_turn_off","completion_time","error_log","success","nasa_tlx","nasaTlx","confidence","toISOString","toggleSwitch","wasOn","isNowOn","isTarget","includes","logEntry","toFixed","setTimeout","prevLog","isDuplicate","some","entry","abs","prevErrors","newState","_objectSpread","markTaskResult","saveSurvey","escapeCSVField","field","str","String","replace","exportToCSV","headers","csvContent","row","blob","Blob","type","url","window","URL","createObjectURL","a","document","createElement","href","download","split","body","appendChild","click","removeChild","revokeObjectURL","updateConditionData","resetForNextCondition","value","Provider"],"sources":["/Users/alexis/BME4A/BME543/Project/src/context/ExperimentContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { generateRandomRoomLayout, getRoomLetters } from '../utils/roomLayouts';\n\nconst ExperimentContext = createContext();\n\nexport const useExperiment = () => {\n  const context = useContext(ExperimentContext);\n  if (!context) {\n    throw new Error('useExperiment must be used within ExperimentProvider');\n  }\n  return context;\n};\n\nexport const ExperimentProvider = ({ children }) => {\n  // Participant info\n  const [participantId, setParticipantId] = useState('');\n  const [participantGroup, setParticipantGroup] = useState('');\n  \n  // Current task state\n  const [currentCondition, setCurrentCondition] = useState(null);\n  const [designType, setDesignType] = useState('traditional'); // 'traditional' | 'buttons' | 'floorplan'\n  const [lightStatus, setLightStatus] = useState('allOff'); // 'allOff' | 'allOn' | 'mixed'\n  const [targetAreas, setTargetAreas] = useState([]); // ['A', 'B', etc.] - lights to turn ON\n  const [lightsToTurnOff, setLightsToTurnOff] = useState([]); // ['C', 'D', etc.] - lights to turn OFF\n  \n  // Room layout and light states\n  const [roomLayout, setRoomLayout] = useState(null); // { numRooms, variation, rooms, roomIds }\n  const [lightStates, setLightStates] = useState({});\n  \n  // Floor plan orientation (0-180 degrees)\n  const [floorPlanOrientation, setFloorPlanOrientation] = useState(0);\n  \n  // Error tracking - detailed log of switch presses\n  const [errorLog, setErrorLog] = useState([]); // Array of { areaId, timestamp, action, wasError }\n  \n  // Task state\n  const [isTaskActive, setIsTaskActive] = useState(false);\n  const [taskStartTime, setTaskStartTime] = useState(null);\n  const [taskEndTime, setTaskEndTime] = useState(null);\n  const [errors, setErrors] = useState(0);\n  const [taskSuccess, setTaskSuccess] = useState(null); // null | true | false\n  \n  // Timer\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const timerIntervalRef = useRef(null);\n  const taskCompletedRef = useRef(false);\n  const autoSavedRef = useRef(false);\n  const lastToggleRef = useRef({ areaId: null, timestamp: 0 }); // Track last toggle to prevent duplicates\n  \n  // All experiment data for CSV export\n  const [experimentData, setExperimentData] = useState([]);\n  \n  // Survey data\n  const [surveyData, setSurveyData] = useState(null);\n  \n  // Initialize light states based on lightStatus and room layout\n  const initializeLightStates = useCallback((status, roomIds) => {\n    const newStates = {};\n    roomIds.forEach(id => { newStates[id] = false; });\n    \n    if (status === 'allOn') {\n      roomIds.forEach(key => { newStates[key] = true; });\n    } else if (status === 'mixed') {\n      // Randomly set 2 lights on\n      const shuffled = [...roomIds].sort(() => 0.5 - Math.random());\n      shuffled.slice(0, Math.min(2, roomIds.length)).forEach(key => { newStates[key] = true; });\n    }\n    \n    return newStates;\n  }, []);\n  \n  // Start task\n  const startTask = useCallback((condition) => {\n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n    \n    // Generate random room layout for this trial\n    const layout = generateRandomRoomLayout();\n    setRoomLayout(layout);\n    \n    // Initialize light states first (based on lightStatus)\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff', layout.roomIds);\n    setLightStates(initialStates);\n    \n    // Generate target areas based on task type\n    const taskType = condition.taskType || 'turnOn2';\n    const shuffled = [...layout.roomIds].sort(() => 0.5 - Math.random());\n    \n    if (taskType === 'turnOn2') {\n      // Turn ON 2 lights\n      const targets = shuffled.slice(0, Math.min(2, layout.roomIds.length));\n      setTargetAreas(targets);\n      setLightsToTurnOff([]);\n    } else if (taskType === 'turnOn1Off1') {\n      // Turn ON 1 light, turn OFF 1 light\n      // For turnOn1Off1, we need at least one light that is currently ON to turn OFF\n      const lightsCurrentlyOn = layout.roomIds.filter(id => initialStates[id] === true);\n      const lightsCurrentlyOff = layout.roomIds.filter(id => initialStates[id] === false);\n      \n      if (lightsCurrentlyOn.length > 0 && lightsCurrentlyOff.length > 0) {\n        // Pick one light to turn ON (from currently OFF)\n        const turnOnTarget = lightsCurrentlyOff[Math.floor(Math.random() * lightsCurrentlyOff.length)];\n        // Pick one light to turn OFF (from currently ON)\n        const turnOffTarget = lightsCurrentlyOn[Math.floor(Math.random() * lightsCurrentlyOn.length)];\n        setTargetAreas([turnOnTarget]);\n        setLightsToTurnOff([turnOffTarget]);\n      } else {\n        // Fallback: if all lights are same state, just pick random ones\n        const turnOnTarget = shuffled[0];\n        const turnOffTarget = shuffled[1] || shuffled[0];\n        setTargetAreas([turnOnTarget]);\n        setLightsToTurnOff([turnOffTarget]);\n      }\n    } else {\n      // Default: turn ON 2 lights\n      const targets = shuffled.slice(0, Math.min(2, layout.roomIds.length));\n      setTargetAreas(targets);\n      setLightsToTurnOff([]);\n    }\n    \n    setErrors(0);\n    setTaskSuccess(null);\n    taskCompletedRef.current = false;\n    autoSavedRef.current = false;\n    setErrorLog([]); // Reset error log for new task\n    setTaskStartTime(Date.now());\n    setTaskEndTime(null);\n    \n    setIsTaskActive(true);\n    \n    // Start timer\n    setElapsedTime(0);\n    timerIntervalRef.current = setInterval(() => {\n      setElapsedTime(prev => prev + 1);\n    }, 1000);\n  }, [initializeLightStates]);\n  \n  // Stop task\n  const stopTask = useCallback(() => {\n    setIsTaskActive(false);\n    setTaskEndTime(Date.now());\n    if (timerIntervalRef.current) {\n      clearInterval(timerIntervalRef.current);\n      timerIntervalRef.current = null;\n    }\n  }, []);\n  \n  // Save task data\n  const saveTaskData = useCallback((survey = null) => {\n    if (!taskStartTime) return null;\n    \n    const duration = taskEndTime ? (taskEndTime - taskStartTime) / 1000 : elapsedTime;\n    \n    // Format error log for CSV\n    const errorLogString = errorLog.map(e => \n      `${e.areaId}:${e.action}:${e.isError ? 'ERROR' : 'OK'}:${e.relativeTime}s`\n    ).join('; ');\n    \n    const data = {\n      participant_id: participantId,\n      group: participantGroup,\n      design_type: designType,\n      lights_status: lightStatus,\n      task_type: currentCondition?.taskType || 'turnOn2',\n      num_rooms: roomLayout?.numRooms || 0,\n      room_variation: roomLayout?.variation || 0,\n      target_areas: targetAreas.join(','),\n      lights_to_turn_off: lightsToTurnOff.join(','),\n      completion_time: duration,\n      errors: errors,\n      error_log: errorLogString,\n      success: taskSuccess === true,\n      nasa_tlx: survey?.nasaTlx || null,\n      confidence: survey?.confidence || null,\n      timestamp: new Date().toISOString()\n    };\n    \n    setExperimentData(prev => [...prev, data]);\n    return data;\n  }, [participantId, participantGroup, designType, lightStatus, currentCondition, targetAreas, lightsToTurnOff, roomLayout,\n      taskStartTime, taskEndTime, elapsedTime, errors, taskSuccess, errorLog]);\n  \n  // Toggle light switch\n  const toggleSwitch = useCallback((areaId) => {\n    // Only allow toggles when task is active\n    // Task completion is manual - moderator must mark it, so we don't check taskCompletedRef here\n    if (!isTaskActive) return;\n    \n    const timestamp = Date.now();\n    \n    // Prevent duplicate processing: if same area toggled within 100ms, skip\n    if (lastToggleRef.current.areaId === areaId && \n        timestamp - lastToggleRef.current.timestamp < 100) {\n      return;\n    }\n    \n    // Mark this toggle\n    lastToggleRef.current = { areaId, timestamp };\n    \n    // Read current state and calculate error BEFORE updating state\n    setLightStates(prev => {\n      const wasOn = prev[areaId];\n      const isNowOn = !wasOn;\n      const isTarget = targetAreas.includes(areaId);\n      const relativeTime = taskStartTime ? (timestamp - taskStartTime) / 1000 : 0;\n      \n      // Determine if this is an error:\n      // - Turning ON a non-target area = ERROR\n      // - Turning OFF = NOT an error (correcting/undoing)\n      // - Turning ON a target area = NOT an error (correct action)\n      \n      let isError = false;\n      let action = '';\n      \n      if (isNowOn && !wasOn) {\n        action = 'turned ON';\n        if (!isTarget) {\n          isError = true; // Turning ON a non-target = ERROR\n        }\n      } else if (!isNowOn && wasOn) {\n        action = 'turned OFF';\n        isError = false; // Turning OFF is never an error\n      }\n      \n      // Create log entry - capture in closure for use outside\n      const logEntry = {\n        areaId,\n        timestamp,\n        relativeTime: relativeTime.toFixed(2),\n        action,\n        isTarget,\n        wasOn,\n        isNowOn,\n        isError\n      };\n      \n      // Update error log and count AFTER state update (using closure to capture values)\n      // This setTimeout ensures error logging happens after state update completes\n      setTimeout(() => {\n        setErrorLog(prevLog => {\n          // Check if duplicate entry exists (same area, action, within 200ms)\n          const isDuplicate = prevLog.some(entry => \n            entry.areaId === logEntry.areaId && \n            entry.action === logEntry.action &&\n            Math.abs(entry.timestamp - logEntry.timestamp) < 200\n          );\n          \n          if (!isDuplicate) {\n            // Only increment error count if this is actually an error\n            if (logEntry.isError) {\n              setErrors(prevErrors => prevErrors + 1);\n            }\n            return [...prevLog, logEntry];\n          }\n          return prevLog;\n        });\n      }, 0);\n      \n      // Create new state\n      const newState = { ...prev, [areaId]: isNowOn };\n      \n      // Task completion is now manual - moderator must mark success/failure\n      // No automatic completion check here\n      \n      return newState;\n    });\n    }, [isTaskActive, targetAreas, lightsToTurnOff, currentCondition, roomLayout, stopTask, taskStartTime]);\n  \n  // Mark task success/failure manually\n  const markTaskResult = useCallback((success) => {\n    taskCompletedRef.current = true;\n    setTaskSuccess(success);\n    stopTask();\n  }, [stopTask]);\n  \n  // Auto-save task data when task completes\n  useEffect(() => {\n    if (taskSuccess !== null && taskEndTime && taskStartTime && !autoSavedRef.current) {\n      // Auto-save without survey (survey can be added later via saveSurvey)\n      saveTaskData();\n      autoSavedRef.current = true;\n    }\n  }, [taskSuccess, taskEndTime, taskStartTime, saveTaskData]);\n  \n  // Save survey data\n  const saveSurvey = useCallback((survey) => {\n    setSurveyData(survey);\n    saveTaskData(survey);\n  }, [saveTaskData]);\n  \n  // Helper function to escape CSV fields (wrap in quotes if contains comma)\n  const escapeCSVField = (field) => {\n    if (field === null || field === undefined) return '';\n    const str = String(field);\n    // If field contains comma, quote, or newline, wrap in quotes and escape internal quotes\n    if (str.includes(',') || str.includes('\"') || str.includes('\\n')) {\n      return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n  };\n  \n  // Export to CSV\n  const exportToCSV = useCallback(() => {\n    if (experimentData.length === 0) return;\n    \n    const headers = [\n      'participant_id',\n      'group',\n      'design_type',\n      'lights_status',\n      'task_type',\n      'num_rooms',\n      'room_variation',\n      'target_areas',\n      'lights_to_turn_off',\n      'completion_time',\n      'errors',\n      'error_log',\n      'success',\n      'nasa_tlx',\n      'confidence',\n      'timestamp'\n    ];\n    \n    const csvContent = [\n      headers.join(','),\n      ...experimentData.map(row => [\n        escapeCSVField(row.participant_id),\n        escapeCSVField(row.group),\n        escapeCSVField(row.design_type),\n        escapeCSVField(row.lights_status),\n        escapeCSVField(row.task_type),\n        escapeCSVField(row.num_rooms),\n        escapeCSVField(row.room_variation),\n        escapeCSVField(row.target_areas), // This will be quoted since it contains commas\n        escapeCSVField(row.lights_to_turn_off || ''), // This will be quoted since it contains commas\n        escapeCSVField(row.completion_time),\n        escapeCSVField(row.errors),\n        escapeCSVField(row.error_log || ''), // Detailed error log\n        escapeCSVField(row.success),\n        escapeCSVField(row.nasa_tlx || ''),\n        escapeCSVField(row.confidence || ''),\n        escapeCSVField(row.timestamp)\n      ].join(','))\n    ].join('\\n');\n    \n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `experiment_data_${participantId || 'export'}_${new Date().toISOString().split('T')[0]}.csv`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    window.URL.revokeObjectURL(url);\n  }, [experimentData, participantId]);\n  \n  // Update condition data without starting task (for preview)\n  // Only updates if no task is currently active\n  const updateConditionData = useCallback((condition) => {\n    // Don't update if a task is active - preserve the current trial\n    if (isTaskActive) {\n      return;\n    }\n    \n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n    \n    // Generate random room layout for preview\n    const layout = generateRandomRoomLayout();\n    setRoomLayout(layout);\n    \n    // Initialize light states first (based on lightStatus)\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff', layout.roomIds);\n    setLightStates(initialStates);\n    \n    // Generate target areas for preview based on task type\n    const taskType = condition.taskType || 'turnOn2';\n    const shuffled = [...layout.roomIds].sort(() => 0.5 - Math.random());\n    \n    if (taskType === 'turnOn2') {\n      const targets = shuffled.slice(0, Math.min(2, layout.roomIds.length));\n      setTargetAreas(targets);\n      setLightsToTurnOff([]);\n    } else if (taskType === 'turnOn1Off1') {\n      const lightsCurrentlyOn = layout.roomIds.filter(id => initialStates[id] === true);\n      const lightsCurrentlyOff = layout.roomIds.filter(id => initialStates[id] === false);\n      \n      if (lightsCurrentlyOn.length > 0 && lightsCurrentlyOff.length > 0) {\n        const turnOnTarget = lightsCurrentlyOff[Math.floor(Math.random() * lightsCurrentlyOff.length)];\n        const turnOffTarget = lightsCurrentlyOn[Math.floor(Math.random() * lightsCurrentlyOn.length)];\n        setTargetAreas([turnOnTarget]);\n        setLightsToTurnOff([turnOffTarget]);\n      } else {\n        const turnOnTarget = shuffled[0];\n        const turnOffTarget = shuffled[1] || shuffled[0];\n        setTargetAreas([turnOnTarget]);\n        setLightsToTurnOff([turnOffTarget]);\n      }\n    } else {\n      const targets = shuffled.slice(0, Math.min(2, layout.roomIds.length));\n      setTargetAreas(targets);\n      setLightsToTurnOff([]);\n    }\n  }, [initializeLightStates, isTaskActive]);\n  \n  // Reset for next condition\n  const resetForNextCondition = useCallback(() => {\n    setErrors(0);\n    setTaskSuccess(null);\n    taskCompletedRef.current = false;\n    autoSavedRef.current = false;\n    setElapsedTime(0);\n    setLightStates({});\n    setSurveyData(null);\n    setErrorLog([]);\n    setLightsToTurnOff([]);\n    lastToggleRef.current = { areaId: null, timestamp: 0 }; // Reset toggle tracking\n    // Note: Don't reset floorPlanOrientation here - let moderator control it\n  }, []);\n  \n  const value = {\n    // Participant\n    participantId,\n    setParticipantId,\n    participantGroup,\n    setParticipantGroup,\n    \n    // Task state\n    currentCondition,\n    designType,\n    lightStatus,\n    targetAreas,\n    lightsToTurnOff,\n    roomLayout,\n    lightStates,\n    floorPlanOrientation,\n    setFloorPlanOrientation,\n    isTaskActive,\n    taskStartTime,\n    taskEndTime,\n    errors,\n    taskSuccess,\n    elapsedTime,\n    errorLog,\n    \n    // Data\n    experimentData,\n    surveyData,\n    \n    // Actions\n    startTask,\n    stopTask,\n    toggleSwitch,\n    markTaskResult,\n    saveTaskData,\n    saveSurvey,\n    exportToCSV,\n    resetForNextCondition,\n    updateConditionData\n  };\n  \n  return (\n    <ExperimentContext.Provider value={value}>\n      {children}\n    </ExperimentContext.Provider>\n  );\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}