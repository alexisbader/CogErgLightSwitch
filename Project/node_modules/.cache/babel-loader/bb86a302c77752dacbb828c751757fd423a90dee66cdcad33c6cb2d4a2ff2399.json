{"ast":null,"code":"/**\n * Latin Square counterbalancing for 3 conditions (Design A, B, C)\n * \n * Each group (A, B, C) has 6 participants with the following Latin Square:\n * \n * Participant → Design Order:\n * A1: 1, 2, 3 (Design A, B, C)\n * A2: 3, 1, 2 (Design C, A, B)\n * A3: 2, 3, 1 (Design B, C, A)\n * A4: 1, 3, 2 (Design A, C, B)\n * A5: 2, 1, 3 (Design B, A, C)\n * A6: 3, 2, 1 (Design C, B, A)\n * \n * Same pattern applies to groups B and C\n */\n\n/**\n * Get the condition order for a given participant ID\n * @param {string} participantId - Participant ID (e.g., \"A1\", \"A2\", \"B1\", \"C6\", etc.)\n * @returns {Array<number>} - Array of condition indices in order (0-2 for the 3 designs)\n */\nexport const getConditionOrderForParticipant = participantId => {\n  if (!participantId) {\n    return [0, 1, 2]; // Default order if no participant ID\n  }\n  const idUpper = participantId.toUpperCase().trim();\n\n  // Extract participant number (1-6) from ID (e.g., \"A1\" -> 1, \"B2\" -> 2)\n  const match = idUpper.match(/[A-Z](\\d+)/);\n  const participantNumber = match ? parseInt(match[1], 10) : 1;\n\n  // Latin Square mapping for 6 participants across 3 conditions\n  // Maps participant number (1-6) to array of condition indices (0-2)\n  const latinSquare = {\n    1: [0, 1, 2],\n    // A, B, C\n    2: [2, 0, 1],\n    // C, A, B\n    3: [1, 2, 0],\n    // B, C, A\n    4: [0, 2, 1],\n    // A, C, B\n    5: [1, 0, 2],\n    // B, A, C\n    6: [2, 1, 0] // C, B, A\n  };\n\n  // Default to first order if participant number is out of range\n  return latinSquare[participantNumber] || latinSquare[1];\n};\n\n/**\n * Get the group letter from a participant ID\n * @param {string} participantId - Participant ID (e.g., \"A1\", \"B2\", etc.)\n * @returns {string} - Group letter (A, B, or C)\n */\nexport const getGroupFromParticipantId = participantId => {\n  if (!participantId) {\n    return '';\n  }\n  const idUpper = participantId.toUpperCase().trim();\n  const match = idUpper.match(/^([A-Z])/);\n  return match ? match[1] : '';\n};\n\n/**\n * Legacy function for backwards compatibility\n * Get the condition order for a given group (now uses participant ID)\n * @param {string} group - Group letter or participant ID (A, B, C, or A1, A2, etc.)\n * @returns {Array<number>} - Array of condition indices in order (0-2)\n * @deprecated Use getConditionOrderForParticipant instead\n */\nexport const getConditionOrderForGroup = group => {\n  // If it's just a letter (A, B, C), treat as A1, B1, C1\n  const groupUpper = group.toUpperCase().trim();\n  if (/^[A-Z]$/.test(groupUpper)) {\n    return getConditionOrderForParticipant(groupUpper + '1');\n  }\n  // Otherwise treat as participant ID\n  return getConditionOrderForParticipant(group);\n};","map":{"version":3,"names":["getConditionOrderForParticipant","participantId","idUpper","toUpperCase","trim","match","participantNumber","parseInt","latinSquare","getGroupFromParticipantId","getConditionOrderForGroup","group","groupUpper","test"],"sources":["/Users/alexis/BME4A/BME543/Project/src/utils/latinSquare.js"],"sourcesContent":["/**\n * Latin Square counterbalancing for 3 conditions (Design A, B, C)\n * \n * Each group (A, B, C) has 6 participants with the following Latin Square:\n * \n * Participant → Design Order:\n * A1: 1, 2, 3 (Design A, B, C)\n * A2: 3, 1, 2 (Design C, A, B)\n * A3: 2, 3, 1 (Design B, C, A)\n * A4: 1, 3, 2 (Design A, C, B)\n * A5: 2, 1, 3 (Design B, A, C)\n * A6: 3, 2, 1 (Design C, B, A)\n * \n * Same pattern applies to groups B and C\n */\n\n/**\n * Get the condition order for a given participant ID\n * @param {string} participantId - Participant ID (e.g., \"A1\", \"A2\", \"B1\", \"C6\", etc.)\n * @returns {Array<number>} - Array of condition indices in order (0-2 for the 3 designs)\n */\nexport const getConditionOrderForParticipant = (participantId) => {\n  if (!participantId) {\n    return [0, 1, 2]; // Default order if no participant ID\n  }\n  \n  const idUpper = participantId.toUpperCase().trim();\n  \n  // Extract participant number (1-6) from ID (e.g., \"A1\" -> 1, \"B2\" -> 2)\n  const match = idUpper.match(/[A-Z](\\d+)/);\n  const participantNumber = match ? parseInt(match[1], 10) : 1;\n  \n  // Latin Square mapping for 6 participants across 3 conditions\n  // Maps participant number (1-6) to array of condition indices (0-2)\n  const latinSquare = {\n    1: [0, 1, 2], // A, B, C\n    2: [2, 0, 1], // C, A, B\n    3: [1, 2, 0], // B, C, A\n    4: [0, 2, 1], // A, C, B\n    5: [1, 0, 2], // B, A, C\n    6: [2, 1, 0]  // C, B, A\n  };\n  \n  // Default to first order if participant number is out of range\n  return latinSquare[participantNumber] || latinSquare[1];\n};\n\n/**\n * Get the group letter from a participant ID\n * @param {string} participantId - Participant ID (e.g., \"A1\", \"B2\", etc.)\n * @returns {string} - Group letter (A, B, or C)\n */\nexport const getGroupFromParticipantId = (participantId) => {\n  if (!participantId) {\n    return '';\n  }\n  \n  const idUpper = participantId.toUpperCase().trim();\n  const match = idUpper.match(/^([A-Z])/);\n  return match ? match[1] : '';\n};\n\n/**\n * Legacy function for backwards compatibility\n * Get the condition order for a given group (now uses participant ID)\n * @param {string} group - Group letter or participant ID (A, B, C, or A1, A2, etc.)\n * @returns {Array<number>} - Array of condition indices in order (0-2)\n * @deprecated Use getConditionOrderForParticipant instead\n */\nexport const getConditionOrderForGroup = (group) => {\n  // If it's just a letter (A, B, C), treat as A1, B1, C1\n  const groupUpper = group.toUpperCase().trim();\n  if (/^[A-Z]$/.test(groupUpper)) {\n    return getConditionOrderForParticipant(groupUpper + '1');\n  }\n  // Otherwise treat as participant ID\n  return getConditionOrderForParticipant(group);\n};\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,+BAA+B,GAAIC,aAAa,IAAK;EAChE,IAAI,CAACA,aAAa,EAAE;IAClB,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACpB;EAEA,MAAMC,OAAO,GAAGD,aAAa,CAACE,WAAW,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;;EAElD;EACA,MAAMC,KAAK,GAAGH,OAAO,CAACG,KAAK,CAAC,YAAY,CAAC;EACzC,MAAMC,iBAAiB,GAAGD,KAAK,GAAGE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;;EAE5D;EACA;EACA,MAAMG,WAAW,GAAG;IAClB,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAAE;IACd,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAAE;IACd,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAAE;IACd,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAAE;IACd,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAAE;IACd,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAE;EAChB,CAAC;;EAED;EACA,OAAOA,WAAW,CAACF,iBAAiB,CAAC,IAAIE,WAAW,CAAC,CAAC,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,yBAAyB,GAAIR,aAAa,IAAK;EAC1D,IAAI,CAACA,aAAa,EAAE;IAClB,OAAO,EAAE;EACX;EAEA,MAAMC,OAAO,GAAGD,aAAa,CAACE,WAAW,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAClD,MAAMC,KAAK,GAAGH,OAAO,CAACG,KAAK,CAAC,UAAU,CAAC;EACvC,OAAOA,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,yBAAyB,GAAIC,KAAK,IAAK;EAClD;EACA,MAAMC,UAAU,GAAGD,KAAK,CAACR,WAAW,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAC7C,IAAI,SAAS,CAACS,IAAI,CAACD,UAAU,CAAC,EAAE;IAC9B,OAAOZ,+BAA+B,CAACY,UAAU,GAAG,GAAG,CAAC;EAC1D;EACA;EACA,OAAOZ,+BAA+B,CAACW,KAAK,CAAC;AAC/C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}