{"ast":null,"code":"var _jsxFileName = \"/Users/alexis/BME4A/BME543/Project/src/context/ExperimentContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ExperimentContext = /*#__PURE__*/createContext();\nexport const useExperiment = () => {\n  _s();\n  const context = useContext(ExperimentContext);\n  if (!context) {\n    throw new Error('useExperiment must be used within ExperimentProvider');\n  }\n  return context;\n};\n_s(useExperiment, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const ExperimentProvider = ({\n  children\n}) => {\n  _s2();\n  // Participant info\n  const [participantId, setParticipantId] = useState('');\n  const [participantGroup, setParticipantGroup] = useState('');\n\n  // Current task state\n  const [currentCondition, setCurrentCondition] = useState(null);\n  const [designType, setDesignType] = useState('traditional'); // 'traditional' | 'floorplan'\n  const [lightStatus, setLightStatus] = useState('allOff'); // 'allOff' | 'allOn' | 'mixed'\n  const [targetAreas, setTargetAreas] = useState([]); // ['A', 'B', etc.]\n\n  // Light states for each area (A, B, C, D)\n  const [lightStates, setLightStates] = useState({\n    A: false,\n    B: false,\n    C: false,\n    D: false\n  });\n\n  // Task state\n  const [isTaskActive, setIsTaskActive] = useState(false);\n  const [taskStartTime, setTaskStartTime] = useState(null);\n  const [taskEndTime, setTaskEndTime] = useState(null);\n  const [errors, setErrors] = useState(0);\n  const [taskSuccess, setTaskSuccess] = useState(null); // null | true | false\n\n  // Timer\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const timerIntervalRef = useRef(null);\n\n  // All experiment data for CSV export\n  const [experimentData, setExperimentData] = useState([]);\n\n  // Survey data\n  const [surveyData, setSurveyData] = useState(null);\n\n  // Initialize light states based on lightStatus\n  const initializeLightStates = useCallback(status => {\n    const newStates = {\n      A: false,\n      B: false,\n      C: false,\n      D: false\n    };\n    if (status === 'allOn') {\n      Object.keys(newStates).forEach(key => {\n        newStates[key] = true;\n      });\n    } else if (status === 'mixed') {\n      // Randomly set 2 lights on\n      const keys = Object.keys(newStates);\n      const shuffled = keys.sort(() => 0.5 - Math.random());\n      shuffled.slice(0, 2).forEach(key => {\n        newStates[key] = true;\n      });\n    }\n    return newStates;\n  }, []);\n\n  // Start task\n  const startTask = useCallback(condition => {\n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n    setTargetAreas(condition.targetAreas || []);\n    setErrors(0);\n    setTaskSuccess(null);\n    setTaskStartTime(Date.now());\n    setTaskEndTime(null);\n\n    // Initialize light states\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff');\n    setLightStates(initialStates);\n    setIsTaskActive(true);\n\n    // Start timer\n    setElapsedTime(0);\n    timerIntervalRef.current = setInterval(() => {\n      setElapsedTime(prev => prev + 1);\n    }, 1000);\n  }, [initializeLightStates]);\n\n  // Stop task\n  const stopTask = useCallback(() => {\n    setIsTaskActive(false);\n    setTaskEndTime(Date.now());\n    if (timerIntervalRef.current) {\n      clearInterval(timerIntervalRef.current);\n      timerIntervalRef.current = null;\n    }\n  }, []);\n\n  // Toggle light switch\n  const toggleSwitch = useCallback(areaId => {\n    if (!isTaskActive) return;\n    setLightStates(prev => {\n      const newState = {\n        ...prev,\n        [areaId]: !prev[areaId]\n      };\n\n      // Check if this was an error (wrong switch)\n      const isTarget = targetAreas.includes(areaId);\n      const wasOn = prev[areaId];\n      const isCorrectToggle = isTarget ? !wasOn : wasOn; // Target should be turned ON, non-targets should stay OFF\n\n      if (!isCorrectToggle) {\n        setErrors(prev => prev + 1);\n      }\n\n      // Check if task is complete (all targets are ON, all non-targets are OFF)\n      const allTargetsOn = targetAreas.every(area => newState[area] === true);\n      const allNonTargetsOff = ['A', 'B', 'C', 'D'].filter(area => !targetAreas.includes(area)).every(area => newState[area] === false);\n      if (allTargetsOn && allNonTargetsOff && taskSuccess === null) {\n        setTaskSuccess(true);\n        stopTask();\n      }\n      return newState;\n    });\n  }, [isTaskActive, targetAreas, taskSuccess, stopTask]);\n\n  // Mark task success/failure manually\n  const markTaskResult = useCallback(success => {\n    setTaskSuccess(success);\n    stopTask();\n  }, [stopTask]);\n\n  // Save task data\n  const saveTaskData = useCallback((survey = null) => {\n    if (!taskStartTime) return;\n    const duration = taskEndTime ? (taskEndTime - taskStartTime) / 1000 : elapsedTime;\n    const data = {\n      participant_id: participantId,\n      group: participantGroup,\n      design_type: designType,\n      lights_status: lightStatus,\n      task_type: (currentCondition === null || currentCondition === void 0 ? void 0 : currentCondition.taskType) || 'single',\n      target_areas: targetAreas.join(','),\n      completion_time: duration,\n      errors: errors,\n      success: taskSuccess === true,\n      nasa_tlx: (survey === null || survey === void 0 ? void 0 : survey.nasaTlx) || null,\n      confidence: (survey === null || survey === void 0 ? void 0 : survey.confidence) || null,\n      preference: (survey === null || survey === void 0 ? void 0 : survey.preference) || null,\n      timestamp: new Date().toISOString()\n    };\n    setExperimentData(prev => [...prev, data]);\n    return data;\n  }, [participantId, participantGroup, designType, lightStatus, currentCondition, targetAreas, taskStartTime, taskEndTime, elapsedTime, errors, taskSuccess]);\n\n  // Save survey data\n  const saveSurvey = useCallback(survey => {\n    setSurveyData(survey);\n    saveTaskData(survey);\n  }, [saveTaskData]);\n\n  // Export to CSV\n  const exportToCSV = useCallback(() => {\n    if (experimentData.length === 0) return;\n    const headers = ['participant_id', 'group', 'design_type', 'lights_status', 'task_type', 'target_areas', 'completion_time', 'errors', 'success', 'nasa_tlx', 'confidence', 'preference', 'timestamp'];\n    const csvContent = [headers.join(','), ...experimentData.map(row => [row.participant_id, row.group, row.design_type, row.lights_status, row.task_type, row.target_areas, row.completion_time, row.errors, row.success, row.nasa_tlx || '', row.confidence || '', row.preference || '', row.timestamp].join(','))].join('\\n');\n    const blob = new Blob([csvContent], {\n      type: 'text/csv;charset=utf-8;'\n    });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `experiment_data_${participantId || 'export'}_${new Date().toISOString().split('T')[0]}.csv`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    window.URL.revokeObjectURL(url);\n  }, [experimentData, participantId]);\n\n  // Reset for next condition\n  const resetForNextCondition = useCallback(() => {\n    setErrors(0);\n    setTaskSuccess(null);\n    setElapsedTime(0);\n    setLightStates({\n      A: false,\n      B: false,\n      C: false,\n      D: false\n    });\n    setSurveyData(null);\n  }, []);\n  const value = {\n    // Participant\n    participantId,\n    setParticipantId,\n    participantGroup,\n    setParticipantGroup,\n    // Task state\n    currentCondition,\n    designType,\n    lightStatus,\n    targetAreas,\n    lightStates,\n    isTaskActive,\n    taskStartTime,\n    taskEndTime,\n    errors,\n    taskSuccess,\n    elapsedTime,\n    // Data\n    experimentData,\n    surveyData,\n    // Actions\n    startTask,\n    stopTask,\n    toggleSwitch,\n    markTaskResult,\n    saveTaskData,\n    saveSurvey,\n    exportToCSV,\n    resetForNextCondition\n  };\n  return /*#__PURE__*/_jsxDEV(ExperimentContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 274,\n    columnNumber: 5\n  }, this);\n};\n_s2(ExperimentProvider, \"AwbTwaMMtbkPwEX+csVn6FqUXm4=\");\n_c = ExperimentProvider;\nvar _c;\n$RefreshReg$(_c, \"ExperimentProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useRef","useEffect","jsxDEV","_jsxDEV","ExperimentContext","useExperiment","_s","context","Error","ExperimentProvider","children","_s2","participantId","setParticipantId","participantGroup","setParticipantGroup","currentCondition","setCurrentCondition","designType","setDesignType","lightStatus","setLightStatus","targetAreas","setTargetAreas","lightStates","setLightStates","A","B","C","D","isTaskActive","setIsTaskActive","taskStartTime","setTaskStartTime","taskEndTime","setTaskEndTime","errors","setErrors","taskSuccess","setTaskSuccess","elapsedTime","setElapsedTime","timerIntervalRef","experimentData","setExperimentData","surveyData","setSurveyData","initializeLightStates","status","newStates","Object","keys","forEach","key","shuffled","sort","Math","random","slice","startTask","condition","Date","now","initialStates","current","setInterval","prev","stopTask","clearInterval","toggleSwitch","areaId","newState","isTarget","includes","wasOn","isCorrectToggle","allTargetsOn","every","area","allNonTargetsOff","filter","markTaskResult","success","saveTaskData","survey","duration","data","participant_id","group","design_type","lights_status","task_type","taskType","target_areas","join","completion_time","nasa_tlx","nasaTlx","confidence","preference","timestamp","toISOString","saveSurvey","exportToCSV","length","headers","csvContent","map","row","blob","Blob","type","url","window","URL","createObjectURL","a","document","createElement","href","download","split","body","appendChild","click","removeChild","revokeObjectURL","resetForNextCondition","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/alexis/BME4A/BME543/Project/src/context/ExperimentContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\n\nconst ExperimentContext = createContext();\n\nexport const useExperiment = () => {\n  const context = useContext(ExperimentContext);\n  if (!context) {\n    throw new Error('useExperiment must be used within ExperimentProvider');\n  }\n  return context;\n};\n\nexport const ExperimentProvider = ({ children }) => {\n  // Participant info\n  const [participantId, setParticipantId] = useState('');\n  const [participantGroup, setParticipantGroup] = useState('');\n  \n  // Current task state\n  const [currentCondition, setCurrentCondition] = useState(null);\n  const [designType, setDesignType] = useState('traditional'); // 'traditional' | 'floorplan'\n  const [lightStatus, setLightStatus] = useState('allOff'); // 'allOff' | 'allOn' | 'mixed'\n  const [targetAreas, setTargetAreas] = useState([]); // ['A', 'B', etc.]\n  \n  // Light states for each area (A, B, C, D)\n  const [lightStates, setLightStates] = useState({\n    A: false,\n    B: false,\n    C: false,\n    D: false\n  });\n  \n  // Task state\n  const [isTaskActive, setIsTaskActive] = useState(false);\n  const [taskStartTime, setTaskStartTime] = useState(null);\n  const [taskEndTime, setTaskEndTime] = useState(null);\n  const [errors, setErrors] = useState(0);\n  const [taskSuccess, setTaskSuccess] = useState(null); // null | true | false\n  \n  // Timer\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const timerIntervalRef = useRef(null);\n  \n  // All experiment data for CSV export\n  const [experimentData, setExperimentData] = useState([]);\n  \n  // Survey data\n  const [surveyData, setSurveyData] = useState(null);\n  \n  // Initialize light states based on lightStatus\n  const initializeLightStates = useCallback((status) => {\n    const newStates = {\n      A: false,\n      B: false,\n      C: false,\n      D: false\n    };\n    \n    if (status === 'allOn') {\n      Object.keys(newStates).forEach(key => { newStates[key] = true; });\n    } else if (status === 'mixed') {\n      // Randomly set 2 lights on\n      const keys = Object.keys(newStates);\n      const shuffled = keys.sort(() => 0.5 - Math.random());\n      shuffled.slice(0, 2).forEach(key => { newStates[key] = true; });\n    }\n    \n    return newStates;\n  }, []);\n  \n  // Start task\n  const startTask = useCallback((condition) => {\n    setCurrentCondition(condition);\n    setDesignType(condition.designType || 'traditional');\n    setLightStatus(condition.lightStatus || 'allOff');\n    setTargetAreas(condition.targetAreas || []);\n    setErrors(0);\n    setTaskSuccess(null);\n    setTaskStartTime(Date.now());\n    setTaskEndTime(null);\n    \n    // Initialize light states\n    const initialStates = initializeLightStates(condition.lightStatus || 'allOff');\n    setLightStates(initialStates);\n    \n    setIsTaskActive(true);\n    \n    // Start timer\n    setElapsedTime(0);\n    timerIntervalRef.current = setInterval(() => {\n      setElapsedTime(prev => prev + 1);\n    }, 1000);\n  }, [initializeLightStates]);\n  \n  // Stop task\n  const stopTask = useCallback(() => {\n    setIsTaskActive(false);\n    setTaskEndTime(Date.now());\n    if (timerIntervalRef.current) {\n      clearInterval(timerIntervalRef.current);\n      timerIntervalRef.current = null;\n    }\n  }, []);\n  \n  // Toggle light switch\n  const toggleSwitch = useCallback((areaId) => {\n    if (!isTaskActive) return;\n    \n    setLightStates(prev => {\n      const newState = { ...prev, [areaId]: !prev[areaId] };\n      \n      // Check if this was an error (wrong switch)\n      const isTarget = targetAreas.includes(areaId);\n      const wasOn = prev[areaId];\n      const isCorrectToggle = isTarget ? !wasOn : wasOn; // Target should be turned ON, non-targets should stay OFF\n      \n      if (!isCorrectToggle) {\n        setErrors(prev => prev + 1);\n      }\n      \n      // Check if task is complete (all targets are ON, all non-targets are OFF)\n      const allTargetsOn = targetAreas.every(area => newState[area] === true);\n      const allNonTargetsOff = ['A', 'B', 'C', 'D']\n        .filter(area => !targetAreas.includes(area))\n        .every(area => newState[area] === false);\n      \n      if (allTargetsOn && allNonTargetsOff && taskSuccess === null) {\n        setTaskSuccess(true);\n        stopTask();\n      }\n      \n      return newState;\n    });\n  }, [isTaskActive, targetAreas, taskSuccess, stopTask]);\n  \n  // Mark task success/failure manually\n  const markTaskResult = useCallback((success) => {\n    setTaskSuccess(success);\n    stopTask();\n  }, [stopTask]);\n  \n  // Save task data\n  const saveTaskData = useCallback((survey = null) => {\n    if (!taskStartTime) return;\n    \n    const duration = taskEndTime ? (taskEndTime - taskStartTime) / 1000 : elapsedTime;\n    \n    const data = {\n      participant_id: participantId,\n      group: participantGroup,\n      design_type: designType,\n      lights_status: lightStatus,\n      task_type: currentCondition?.taskType || 'single',\n      target_areas: targetAreas.join(','),\n      completion_time: duration,\n      errors: errors,\n      success: taskSuccess === true,\n      nasa_tlx: survey?.nasaTlx || null,\n      confidence: survey?.confidence || null,\n      preference: survey?.preference || null,\n      timestamp: new Date().toISOString()\n    };\n    \n    setExperimentData(prev => [...prev, data]);\n    return data;\n  }, [participantId, participantGroup, designType, lightStatus, currentCondition, targetAreas, \n      taskStartTime, taskEndTime, elapsedTime, errors, taskSuccess]);\n  \n  // Save survey data\n  const saveSurvey = useCallback((survey) => {\n    setSurveyData(survey);\n    saveTaskData(survey);\n  }, [saveTaskData]);\n  \n  // Export to CSV\n  const exportToCSV = useCallback(() => {\n    if (experimentData.length === 0) return;\n    \n    const headers = [\n      'participant_id',\n      'group',\n      'design_type',\n      'lights_status',\n      'task_type',\n      'target_areas',\n      'completion_time',\n      'errors',\n      'success',\n      'nasa_tlx',\n      'confidence',\n      'preference',\n      'timestamp'\n    ];\n    \n    const csvContent = [\n      headers.join(','),\n      ...experimentData.map(row => [\n        row.participant_id,\n        row.group,\n        row.design_type,\n        row.lights_status,\n        row.task_type,\n        row.target_areas,\n        row.completion_time,\n        row.errors,\n        row.success,\n        row.nasa_tlx || '',\n        row.confidence || '',\n        row.preference || '',\n        row.timestamp\n      ].join(','))\n    ].join('\\n');\n    \n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `experiment_data_${participantId || 'export'}_${new Date().toISOString().split('T')[0]}.csv`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    window.URL.revokeObjectURL(url);\n  }, [experimentData, participantId]);\n  \n  // Reset for next condition\n  const resetForNextCondition = useCallback(() => {\n    setErrors(0);\n    setTaskSuccess(null);\n    setElapsedTime(0);\n    setLightStates({\n      A: false,\n      B: false,\n      C: false,\n      D: false\n    });\n    setSurveyData(null);\n  }, []);\n  \n  const value = {\n    // Participant\n    participantId,\n    setParticipantId,\n    participantGroup,\n    setParticipantGroup,\n    \n    // Task state\n    currentCondition,\n    designType,\n    lightStatus,\n    targetAreas,\n    lightStates,\n    isTaskActive,\n    taskStartTime,\n    taskEndTime,\n    errors,\n    taskSuccess,\n    elapsedTime,\n    \n    // Data\n    experimentData,\n    surveyData,\n    \n    // Actions\n    startTask,\n    stopTask,\n    toggleSwitch,\n    markTaskResult,\n    saveTaskData,\n    saveSurvey,\n    exportToCSV,\n    resetForNextCondition\n  };\n  \n  return (\n    <ExperimentContext.Provider value={value}>\n      {children}\n    </ExperimentContext.Provider>\n  );\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}